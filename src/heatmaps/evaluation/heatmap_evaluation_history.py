from src.heatmaps import plot_heatmap_x, plot_heatmap_y, plot_heatmap_z
from src.heatmaps.evaluation.utils import plot_evaluation

import numpy as np
import seaborn as sns

import os
import pickle


class HeatmapEvaluationHistory:
    def __init__(self, method, auc, arr_auc, arr_heatmap, arr_x, arr_y, arr_y_pred, arr_y_pred_heatmap,
                 arr_voxels, arr_max_voxels, arr_step_size):
        """

        :param method:
        :param auc:
        :param arr_auc:
        :param arr_heatmap:
        :param arr_x:
        :param arr_y:
        :param arr_y_pred:
        :param arr_y_pred_heatmap: predictions (activations) for images generated by evaluation sequence
        :param arr_voxels:
        :param arr_max_voxels:
        :param arr_step_size:
        """
        self.method = method
        self.auc = auc
        self.arr_auc = arr_auc
        self.arr_heatmap = arr_heatmap
        self.arr_x = arr_x
        self.arr_y = arr_y
        self.arr_y_pred = arr_y_pred
        self.arr_y_pred_heatmap = arr_y_pred_heatmap
        self.arr_voxels = arr_voxels
        self.arr_max_voxels = arr_max_voxels
        self.arr_step_size = arr_step_size

    @staticmethod
    def load(path, filename):
        p = os.path.join(path, f'{filename}.cls')
        with open(p, 'rb') as file:
            return pickle.load(file)

    def save(self, path, filename):
        p = os.path.join(path, f'{filename}.cls')
        if not os.path.exists(path):
            os.mkdir(path)
        with open(p, 'wb') as file:
            pickle.dump(self, file, protocol=pickle.HIGHEST_PROTOCOL)
            print(f'saved to: {p}')
            
    def _description(self, percentage=True):
        arr_auc = self.__get_arr_auc(percentage)
        
        return {
            "heatmaps": len(self.arr_heatmap),
            "auc_mean": np.mean(arr_auc),
            "auc_p25": np.percentile(arr_auc, 25),
            "auc_median": np.median(arr_auc),
            "auc_p75": np.percentile(arr_auc, 75),
            "auc_max": np.max(arr_auc),
            "auc_min": np.min(arr_auc),
            "auc_std": np.std(arr_auc),
        }

    def description(self, percentage=True):
        data = self._description(percentage)
        
        print(f'evaluated heatmaps: {data["heatmaps"]}')
        print(f'auc')
        print(f'\tmean:   {data["auc_mean"]:20,}')
        print(f'\tmedian: {data["auc_median"]:20,}')
        print(f'\tmax:    {data["auc_max"]:20,}')
        print(f'\tmin:    {data["auc_min"]:20,}')
        print(f'\tstd:    {data["auc_std"]:20,}')

    def plot_auc(self, percentage=True):
        arr_auc = self.__get_arr_auc(percentage)
        f_grid = sns.displot(arr_auc)
        f_grid.set_axis_labels('AUC (area under curve)')
        f_grid.axes[0][0].set_title('Distribution of AUC metric for generated heatmaps')
        return f_grid

    def list_auc(self, round_auc=False, percentage=True):
        arr_auc = self.__get_arr_auc(percentage)
        arr = list(enumerate(list(np.copy(np.array(arr_auc)))))
        arr.sort(key=lambda v: v[1])

        for i, auc in arr:
            print(f'idx: {i:4}, auc: {round(auc) if round_auc else auc:20,}')

    def plot_evaluation(self, idx):
        self.__ensure_idx(idx)
        return plot_evaluation(self.arr_y[idx], self.arr_y_pred_heatmap[idx], self.arr_step_size[idx],
                               self.arr_voxels[idx],
                               self.arr_max_voxels[idx], self.method)

    def plot_heatmap_x(self, idx, i=None, title_1=None, title_2=None):
        self.__ensure_idx(idx)
        plot_heatmap_x(self.arr_x[idx], self.arr_y[idx], self.arr_y_pred[idx], self.arr_heatmap[idx], i, title_1=title_1, title_2=title_2)

    def plot_heatmap_y(self, idx, i=None, title_1=None, title_2=None):
        self.__ensure_idx(idx)
        plot_heatmap_y(self.arr_x[idx], self.arr_y[idx], self.arr_y_pred[idx], self.arr_heatmap[idx], i, title_1=title_1, title_2=title_2)

    def plot_heatmap_z(self, idx, i=None, title_1=None, title_2=None):
        self.__ensure_idx(idx)
        plot_heatmap_z(self.arr_x[idx], self.arr_y[idx], self.arr_y_pred[idx], self.arr_heatmap[idx], i, title_1=title_1, title_2=title_2)

    def __ensure_idx(self, idx):
        if idx >= len(self.arr_x):
            raise Exception(f'image with index {idx} does not exist in the history!')
    
    def __get_arr_auc(self, percentage):
        div = self.arr_max_voxels[0] if percentage and len(self.arr_max_voxels) else 1
        return np.array(self.arr_auc) / div
    